//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";

interface IQuickswapStakingRewards {
  function stake(uint256 amount) external;
  function withdraw(uint256 amount) external;
  function getReward() external;
}

interface UniswapV2Router02 {
  function addLiquidity(
          address tokenA,
          address tokenB,
          uint amountADesired,
          uint amountBDesired,
          uint amountAMin,
          uint amountBMin,
          address to,
          uint deadline
      ) external;

  function removeLiquidity(
          address tokenA,
          address tokenB,
          uint liquidity,
          uint amountAMin,
          uint amountBMin,
          address to,
          uint deadline
      ) external;
}

interface IERC20 {
  function balanceOf(address a) external view returns(uint);
  function approve(address spender, uint tokens) external returns (bool success);
  function decimals() external view returns(uint);
  function totalSupply() external view returns(uint);
}

interface IUniswapV2Pair {
    function sync()        external;
    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast
}

interface PriceFeed {
  function getPrice(address token) external view returns(uint);
}


contract UniswapLPManager {
  IERC20 immutable lpToken;
  IERC20 immutable token0;
  IERC20 immutable token1;
  address immutable uniReserve;
  UniswapV2Router02 immutable uniRouter;
  PriceFeed immutable feed;
  IQuickswapStakingRewards immutable quickswapStaking;

  // callable by anyone
  function stakeLP() public {
    // give allowance every time as gas in polygon is cheap
    uint amount = lpToken.balanceOf(address(this));
    require(lpToken.approve(address(quickswapStaking), amount), "stakeLP: approve failed");
    quickswapStaking.stake(amount);
  }

  function withdrawLP(uint lpAmount) internal {
    quickswapStaking.withdraw(lpAmount);
    quickswapStaking.getReward();    
  }

  function getReserveBalances() public view returns(uint balance0, uint balance1) {
    (uint112 bal0, uint112 bal1, ) = IUniswapV2Pair(uniReserve).getReserves();

    balance0 = uint(bal0);
    balance1 = uint(bal1);    
  }

  function syncAndGetReserveBalances() public returns(uint balance0, uint balance1) {
    IUniswapV2Pair(uniReserve).sync();
    return getReserveBalances();
  }

  function withdrawToken(IERC20 token, uint amount) internal {
    (uint bal0, uint bal1) = syncAndGetReserveBalances();

    uint bal = 0;
    if(token == token0) bal = bal0;
    else if(token == token1) bal = bal1;
    else revert("withdrawToken: invalid token");

    uint lpAmount = amount * lpToken.totalSupply() / bal; // TODO roundup

    uint min0 = bal0 * lpAmount / lpToken.totalSupply(); // TODO - do not read balances directly, use get reserve
    uint min1 = bal1 * lpAmount / lpToken.totalSupply();    

    withdrawLP(lpAmount);
    uniRouter.removeLiquidity(token0, token1, lpAmount, min0, min1, address(this), block.timestamp);
  }

  function getTokenBalance(IERC20 token) public view returns(uint) {
    (uint bal0, uint bal1) = syncAndGetReserveBalances();
    uint bal = 0;
    if(token == token0) bal = bal0;
    else if(token == token1) bal = bal1;
    // else bal = 0

    return bal * getLPBalance() / lpToken.totalSupply();
  }

  // callable by anyone
  event InventoryDeposit(uint amount0, uint amount1);
  function depositInventory() public {
    (uint bal0, uint bal1) = syncAndGetReserveBalances();

    // 1. check that reserve was not maipulated
    uint value0 = bal0 * feed.getPrice(token1);
    uint value1 = bal1 * feed.getPrice(token0);

    if(value0 * 100 / value1 > 102 || value1 * 100 / value0 > 102) { // TODO - what is the loss for 2% deviation?
      emit InventoryDeposit(0, 0);
      return;
    }

    // 2. calc token0 and token1 amounts
    uint amount0 = token0.balanceOf(address(this));
    uint amount1 = token1.balanceOf(address(this));

    if(amount0 * bal1 > amount1 * bal0) {
      // amount0 / amount1 > uniswap ratio => too much amount0
      amount0 = amount1 * bal0 / bal1;
    }
    else {
      // amount0 / amount1 < uniswap ratio => too much amount1
      amount1 = amount0 * bal1 / bal0;      
    }

    // 3. give allowance
    uint allowance0 = amount0 * 11 / 10;
    uint allowance1 = amount1 * 11 / 10;

    require(token0.approve(uniReserve, allowance0), "depositInventory: token0 approve failed");
    require(token1.approve(uniReserve, allowance1), "depositInventory: token1 approve failed");

    // 4. call add liquidity
    uint min0 = amount0 - 1;
    uint min1 = amount1 - 1;    

    uniRouter.addLiquidity(token0, token1, amount0, amount1, min0, min1, address(this), block.timestamp);

    // 5. reset allowance
    require(token0.approve(uniReserve, 0), "depositInventory: token0 approve failed");
    require(token1.approve(uniReserve, 0), "depositInventory: token1 approve failed");    
  }

    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687
  function sqrt (uint _x) public pure returns (uint) {
    if (_x == 0) return 0;
    else {
      uint xx = _x;
      uint r = 1;
      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }
      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }
      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }
      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }
      if (xx >= 0x100) { xx >>= 8; r <<= 4; }
      if (xx >= 0x10) { xx >>= 4; r <<= 2; }
      if (xx >= 0x8) { r <<= 1; }
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1;
      r = (r + _x / r) >> 1; // Seven iterations should be enough
      uint r1 = _x / r;
      return (r < r1 ? r : r1);
    }
  }

  function getLPValue() public returns(uint) {
    uint unit0 = token0.decimals();
    uint unit1 = token1.decimals();

    (uint balance0, uint balance1) = syncAndGetReserveBalances();    

    uint value0 = balance0 * feed.getPrice(token0) / (10 ** token0.decimals());
    uint value1 = balance1 * feed.getPrice(token1) / (10 ** token1.decimals());

    return sqrt(value0 * value1) * 2 * (10 ** lpToken.decimals()) / lpToken.totalSupply();
  }

  function getLPBalance() public view returns(uint) {
    return IERC20(address(quickswapStaking)).balanceOf(address(this));
  }
}
